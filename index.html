<!DOCTYPE HTML>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<title>3D Pipes Screensaver</title>
		<link rel="icon" href="images/meta/icon-16x16.png" type="image/png" sizes="16x16"/>
		<link rel="icon" href="images/meta/icon-32x32.png" type="image/png" sizes="32x32"/>
		<link rel="icon" href="images/meta/favicon.ico" type="image/x-icon" sizes="16x16 32x32"/>
		<!-- Note: chrome does not display the 16px icon in its 16px space in this case -->
		<!-- but the 16px icon isn't objectively better, so whatever -->
		<style>
			html, body {
				border: 0;
				margin: 0;
				padding: 0;
				width: 100%;
				height: 100%;
				overflow: hidden;
				background: #000;
				color: white;
				font-family: sans-serif;
			}
			#canvas-container {
				position: relative;
			}
			canvas {
				position: absolute;
				left: 0;
				top: 0;
			}
			.controls {
				padding: 10px;
				background: rgba(0, 0, 0, 0.4);
				text-shadow: 0 0 2px black;
				position: absolute;
				top: 0;
				left: 0;
			}
			.controls,
			.fork-me {
				z-index: 1;
			}
			.controls th {
				text-align: left;
			}
			.controls th,
			.controls td {
				padding: 10px;
			}
			#fullscreen-button {
				margin: 10px;
			}
			button {
				border: 1px solid gray;
				background: rgba(128, 128, 128, 0.4);
				color: inherit;
				display: flex;
				padding: 5px 10px;
			}
			button svg {
				margin-right: 5px;
				height: 1em;
			}
			button svg path {
				fill: currentColor;
			}
		</style>
		<script src="lib/sri-fallback.js"></script>
		<script x-sri-fallback="lib/three.min.js" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/98/three.min.js" integrity="sha256-MbIcpOhIEGLabqntH1B7ZgE7a6V0TrocmKouz1npT1g=" crossorigin="anonymous"></script>
		<script src="lib/TeapotBufferGeometry.js"></script>
		<meta name="viewport" content="width=device-width, user-scalable=no">
	</head>
	<body>
		<a href="https://github.com/1j01/pipes"><img class="fork-me" style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/52760788cde945287fbb584134c4cbc2bc36f904/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png"></a>
		<div class="controls">
			<button id="fullscreen-button">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 438.543 438.543">
					<path d="M407.42 159.029c3.62 3.616 7.898 5.428 12.847 5.428 2.282 0 4.668-.476 7.139-1.429 7.426-3.235 11.136-8.853 11.136-16.846V18.276c0-4.949-1.807-9.231-5.428-12.847-3.61-3.617-7.898-5.424-12.847-5.424H292.36c-7.991 0-13.607 3.805-16.848 11.419-3.23 7.423-1.902 13.99 4 19.698l41.111 41.112-101.352 101.355L117.917 72.231l41.112-41.112c5.901-5.708 7.232-12.275 3.999-19.698C159.789 3.807 154.175 0 146.182 0H18.276C13.324 0 9.041 1.809 5.425 5.426 1.808 9.042.001 13.324.001 18.273V146.18c0 7.996 3.809 13.61 11.419 16.846 2.285.948 4.57 1.429 6.855 1.429 4.948 0 9.229-1.812 12.847-5.427l41.112-41.109 101.354 101.354L72.234 320.622l-41.112-41.113c-5.711-5.903-12.275-7.231-19.702-4.001C3.806 278.749.001 284.364.001 292.362v127.906c0 4.948 1.807 9.229 5.424 12.847 3.619 3.614 7.902 5.421 12.851 5.421h127.906c7.996 0 13.61-3.806 16.846-11.416 3.234-7.427 1.903-13.99-3.999-19.705l-41.112-41.106L219.271 264.95l101.353 101.361-41.114 41.11c-5.899 5.708-7.228 12.279-3.997 19.698 3.237 7.617 8.856 11.423 16.851 11.423h127.907c4.948 0 9.232-1.813 12.847-5.428 3.613-3.613 5.42-7.898 5.42-12.847V292.362c0-7.994-3.709-13.613-11.136-16.851-7.802-3.23-14.462-1.903-19.985 4.004l-41.106 41.106-101.359-101.35L366.31 117.917l41.11 41.112z" fill="#FFF"/>
				</svg>
				Enter Fullscreen
			</button>
			<table>
				<thead>
					<tr>
						<th>Mouse button</th>
						<th>Action</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Primary</td>
						<td>Change view</td>
					</tr>
					<tr>
						<td>Secondary</td>
						<td>Clear pipes and restart</td>
					</tr>
				</tbody>
			</table>
		</div>
		<div id="canvas-container">
			<canvas id="canvas-webgl"></canvas>
			<canvas id="canvas-2d"></canvas>
		</div>
		<script>
			var box = new THREE.Box3(
				new THREE.Vector3(-500,-500,-500),
				new THREE.Vector3(500,500,500)
			);
			var cylinderBetweenPoints = function(point1, point2, material){
				var direction = new THREE.Vector3().subVectors(point2, point1);
				var arrow = new THREE.ArrowHelper(direction.clone().normalize(), point1);
				
				var geom = new THREE.CylinderGeometry(10, 10, direction.length()-20*0, 10, 4, true);
				var mesh = new THREE.Mesh(geom, material);
				
				mesh.rotation.setFromQuaternion(arrow.quaternion);
				mesh.position.addVectors(point1, direction.multiplyScalar(0.5));
				mesh.updateMatrix();
				return mesh;
			};
			var textures = {};
			var Pipe = function(scene, o){
				var p = this;
				p.pos = randomPointInBox(box);
				p.o3d = new THREE.Object3D();
				scene.add(p.o3d);
				if(o.texture){
					p.mat = new THREE.MeshLambertMaterial({
						map: textures[o.texture]
					});
				}else{
					var color = ~rand(0, 0xffffff);
					var emissive = new THREE.Color(color).multiplyScalar(0.3);
					p.mat = new THREE.MeshPhongMaterial({
						specular: 0xa9fcff,
						color: color,
						emissive: emissive,
						shininess: 100,
					});
				}
				// TODO: DRY
				var ball = new THREE.Mesh(new THREE.SphereGeometry(15, 8, 8), p.mat);
				ball.position.copy(p.pos);
				p.o3d.add(ball);

				// var elbow;
				
				p.update = function(){
					var dist = Math.floor(rand(1,5))*50;
					var newpos = p.pos.clone();
					if(chance(1/2)){
						if(chance(1/3)){
							newpos.x += dist;
						}else if(chance(1/2)){
							newpos.y += dist;
						}else{
							newpos.z += dist;
						}
					}else{
						if(chance(1/3)){
							newpos.x -= dist;
						}else if(chance(1/2)){
							newpos.y -= dist;
						}else{
							newpos.z -= dist;
						}
					}
					if(!box.containsPoint(newpos)){
						return;
					}
					//pipe
					var cylinder = cylinderBetweenPoints(p.pos, newpos, p.mat);
					cylinder.overdraw = true;
					p.o3d.add(cylinder);
					
					// if(elbow){
					// 	//elbow.rotateX(Math.PI);
					// 	//elbow.rotation.set(...)
					// 	p.o3d.add(elbow);
					// }
					
					//joint
					if(chance(1/200 + options.TEAPOTS/20)){
						//var tptex = textures[o.texture].clone();
						//tptex.repeat.set(1,1);
						// THREE.TeapotBufferGeometry = function ( size, segments, bottom, lid, body, fitLid, blinn )
						var teapot = new THREE.Mesh(
							new THREE.TeapotBufferGeometry(15, true, true, true, true, true), 
							p.mat
							//new THREE.MeshLambertMaterial({map: tptex})
						);
						teapot.position.copy(p.pos);
						teapot.rotation.x = Math.floor(rand(0,50))*Math.PI/2;
						teapot.rotation.y = Math.floor(rand(0,50))*Math.PI/2;
						teapot.rotation.z = Math.floor(rand(0,50))*Math.PI/2;
						p.o3d.add(teapot);
					}else if(chance(1/20)){
						//ball
						var ball = new THREE.Mesh(new THREE.SphereGeometry(15, 8, 8), p.mat);
						ball.position.copy(p.pos);
						p.o3d.add(ball);
					}else{
						//elbow
						//var r = 20;
						//elbow = new THREE.Mesh(new THREE.TorusGeometry(r, 10, 8, 8, Math.PI/2), p.mat);
						//elbow.position.copy(p.pos);
						
						//elball (not a proper elbow)
						var elball = new THREE.Mesh(new THREE.SphereGeometry(10, 8, 8), p.mat);
						elball.position.copy(p.pos);
						p.o3d.add(elball);

						// extrude an elbow joint
						/*
						function ArcCurve( scale ) {
							THREE.Curve.call( this );
							this.scale = ( scale === undefined ) ? 1 : scale;
						}

						ArcCurve.prototype = Object.create( THREE.Curve.prototype );
						ArcCurve.prototype.constructor = ArcCurve;

						ArcCurve.prototype.getPoint = function ( t ) {
							function circ(t) {
								return Math.sqrt(1 - t*t);
							}

							var tx = t;
							var ty = circ(t);
							var tz = 0;

							return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );
						};

						var extrudePath = new ArcCurve( 10 );

						var extrusionSegments = 100;
						var radiusSegments = 10;
						var radius = 10;
						var tubeGeometry = new THREE.TubeBufferGeometry( extrudePath, extrusionSegments, radius, radiusSegments, false );
						
						var elbow = new THREE.Mesh(tubeGeometry, p.mat);
						elbow.position.copy(p.pos);
						p.o3d.add(elbow);
						*/
					}
					
					//finish
					p.pos = newpos;
					
				};
				p.clear = function(){
					scene.remove(p.o3d);
				};
			};
			
			
			var pipes = [];
			var time = 0;
			var options = {
				multiple: true,
				texture: false,
				joints: "mixed",
				interval: [16, 24], // range of seconds between fade-outs
				TEAPOTS: 0
			};

			var canvasContainer = document.getElementById("canvas-container");

			// 2d canvas for dissolve effect
			var canvas2d = document.getElementById("canvas-2d");
			var ctx2d = canvas2d.getContext("2d");

			// renderer
			var canvasWebGL = document.getElementById("canvas-webgl");
			var renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true, canvas: canvasWebGL });
			renderer.setSize(window.innerWidth, window.innerHeight);

			// camera
			var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100000);
			look();
			
			// scene
			var scene = new THREE.Scene();
			
			// lighting
			var ambientLight = new THREE.AmbientLight(0x111111);
			scene.add(ambientLight);
			
			var directionalLightL = new THREE.DirectionalLight(0xffffff, 0.9);
			directionalLightL.position.set(-1.2, 1.5, 0.5);
			scene.add(directionalLightL);

			// dissolve transition effect

			var dissolveRects = [];
			var dissolveRectsIndex = -1;
			var dissolveRectsPerRow = 50;
			var dissolveRectsPerColumn = 50;
			var dissolveTransitionSeconds = 2;
			var dissolveTransitionFrames = dissolveTransitionSeconds * 60;
			var dissolveEndCallback;

			function dissolve(endCallback, seconds) {
				// TODO: determine rect sizes better and simplify
				// silly approximation of squares of a particular size:
				dissolveRectsPerRow = Math.ceil(window.innerWidth / 20);
				dissolveRectsPerColumn = Math.ceil(window.innerHeight / 20);

				dissolveRects = new Array(dissolveRectsPerRow * dissolveRectsPerColumn).fill(null).map(function(_null, index){
					return {x: index % dissolveRectsPerRow, y: Math.floor(index / dissolveRectsPerRow)};
				});
				shuffleArrayInPlace(dissolveRects);
				dissolveRectsIndex = 0;
				dissolveTransitionSeconds = seconds;
				dissolveTransitionFrames = dissolveTransitionSeconds * 60;
				dissolveEndCallback = endCallback;
			}
			function finishDissolve(){
				dissolveEndCallback();
				dissolveRects = [];
				dissolveRectsIndex = -1;
				ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
			}
			
			var clearing = false;
			var clear_tid = -1;
			function clear(fast){
				clearTimeout(clear_tid);
				clear_tid = setTimeout(clear, rand(options.interval[0], options.interval[1]) * 1000);
				if(!clearing){
					clearing = true;
					var fade_out_time = fast ? 0.2 : 2;
					dissolve(function(){
						renderer.clear();
						for(var i=0; i<pipes.length; i++){
							pipes[i].clear();
						}
						pipes = [];
						time = 0;
						look();
						clearing = false;
					}, fade_out_time);
				}
			}
			clear_tid = setTimeout(clear, rand(options.interval[0], options.interval[1]) * 1000);
			
			// this function is executed on each animation frame
			function animate(){
				if(options.texture && !textures[options.texture]){
					var t = THREE.ImageUtils.loadTexture(options.texture);
					t.wrapS = t.wrapT = THREE.RepeatWrapping;
					t.repeat.set(2,2);
					textures[options.texture] = t;
				}
				// update
				time++;
				for(var i=0; i<pipes.length; i++){
					pipes[i].update(scene);
				}
				if(pipes.length === 0){
					var o = options;
					if(chance(1/20)){
						o = JSON.parse(JSON.stringify(options));
						o.TEAPOTS = 1; o.texture = "images/textures/candycane.png";
						if(!textures[o.texture]){
							var t = THREE.ImageUtils.loadTexture(o.texture);
							t.wrapS = t.wrapT = THREE.RepeatWrapping;
							t.repeat.set(2,2);
							textures[o.texture] = t;
						}
					}
					for(var i=0; i<1+options.multiple*(1+chance(1/10)); i++){
						pipes.push(new Pipe(scene,o));
					}
				}
				
				renderer.render(scene, camera);
				
				if(canvas2d.width !== window.innerWidth || canvas2d.height !== window.innerHeight) {
					canvas2d.width = window.innerWidth;
					canvas2d.height = window.innerHeight;
					// TODO: DRY!
					// actually: TODO: make the 2d canvas really low resolution, and stretch it with CSS, with pixelated interpolation
					if(dissolveRectsIndex > -1){
						for(var i=0; i<dissolveRectsIndex; i++){
							var rect = dissolveRects[i];
							// TODO: could precompute rect in screen space, or at least make this clearer with "xIndex"/"yIndex"
							var rectWidth = innerWidth / dissolveRectsPerRow;
							var rectHeight = innerHeight / dissolveRectsPerColumn;
							ctx2d.fillStyle = "black";
							ctx2d.fillRect(Math.floor(rect.x * rectWidth), Math.floor(rect.y * rectHeight), Math.ceil(rectWidth), Math.ceil(rectHeight));
						}
					}
				}
				if(dissolveRectsIndex > -1){
					// TODO: calibrate based on time transition is actually taking
					var rectsAtATime = Math.floor(dissolveRects.length / dissolveTransitionFrames);
					for(var i=0; i<rectsAtATime && dissolveRectsIndex < dissolveRects.length; i++){
						var rect = dissolveRects[dissolveRectsIndex];
						// TODO: could precompute rect in screen space, or at least make this clearer with "xIndex"/"yIndex"
						var rectWidth = innerWidth / dissolveRectsPerRow;
						var rectHeight = innerHeight / dissolveRectsPerColumn;
						ctx2d.fillStyle = "black";
						ctx2d.fillRect(Math.floor(rect.x * rectWidth), Math.floor(rect.y * rectHeight), Math.ceil(rectWidth), Math.ceil(rectHeight));
						dissolveRectsIndex += 1;
					}
					if(dissolveRectsIndex === dissolveRects.length){
						finishDissolve();
					}
				}
 				
				requestAnimationFrame(animate);
			}
			
			function look(){
				// TODO: never don't change the view
				if(chance(1/2)){
					//head-on view
					
					camera.position.set(0, 0, 700);
				}else{
					//random view
					
					var vector = new THREE.Vector3(700, 0, 0);
					
					var axis = new THREE.Vector3(rand(-1,1), rand(-1,1), rand(-1,1));
					var angle = Math.PI / 2;
					var matrix = new THREE.Matrix4().makeRotationAxis(axis, angle);
					
					vector.applyMatrix4( matrix );
					camera.position.copy(vector);
				}
				var center = new THREE.Vector3(0,0,0);
				camera.lookAt(center);
			}
			
			addEventListener('resize', function(){
				renderer.setSize(window.innerWidth, window.innerHeight);
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			}, false);
			
			canvasContainer.addEventListener('mousedown', function(e){
				e.preventDefault();
				if(e.button){
					clear(true);
				}else{
					look();
				}
			});

			var fullscreenButton = document.getElementById("fullscreen-button");
			fullscreenButton.addEventListener('click', function(e){
				if(canvasContainer.requestFullscreen){ // W3C API
					canvasContainer.requestFullscreen();
				}else if (canvasContainer.mozRequestFullScreen){ // Mozilla current API
					canvasContainer.mozRequestFullScreen();
				}else if (canvasContainer.webkitRequestFullScreen){ // Webkit current API
					canvasContainer.webkitRequestFullScreen();
				}
			}, false);
			
			addEventListener('contextmenu', function(e){
				e.preventDefault();
			}, false);
			
			// start animation
			animate();
			
			/**************\
			|boring helpers|
			\**************/
			function rand(x1,x2){
				return Math.random()*(x2-x1)+x1;
			}
			function chance(value){
				return rand(0, 1) < value;
			}
			function shuffleArrayInPlace(array) {
				for (var i = array.length - 1; i > 0; i--) {
					var j = Math.floor(Math.random() * (i + 1));
					var temp = array[i];
					array[i] = array[j];
					array[j] = temp;
				}
			}
			function randomPointInBox(box){
				return new THREE.Vector3(
					rand(box.min.x, box.max.x),
					rand(box.min.y, box.max.y),
					rand(box.min.z, box.max.z)
				);
			};
		</script>
	</body>
</html>
